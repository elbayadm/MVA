function [net, info] = cnn_sketch(varargin)

run('../matlab/vl_setupnn.m') ;

opts.expDir = fullfile('sketch_model') ;
opts.imdbPath = fullfile('dataset_with_order_info_256.mat');
opts.train.batchSize = 135 ;
opts.train.numEpochs = 500;
opts.train.continue = true ;
opts.train.useGpu = false ;
opts.train.learningRate = 0.001 ; 
opts.train.expDir = opts.expDir ;
opts = vl_argparse(opts, varargin) ;

load(opts.imdbPath) ;

scal = 1 ;
bias = 0.01;
net.layers = {} ;

net.layers{end+1} = struct('type', 'conv', ...
                           'filters', 0.01/scal * randn(15, 15, size(imdb.images.data,3), 64, 'single'), ...
                           'biases', bias*ones(1, 64, 'single'), ...
                           'stride', 3, ...
                           'pad', 0, ...
                           'filtersLearningRate', 1, ...
                           'biasesLearningRate', 2, ...
                           'filtersWeightDecay', 1, ...
                           'biasesWeightDecay', 0) ;
net.layers{end+1} = struct('type', 'relu') ;
net.layers{end+1} = struct('type', 'pool', ...
                           'method', 'max', ...
                           'pool', [3 3], ...
                           'stride', 2, ...
                           'pad', 0) ;

net.layers{end+1} = struct('type', 'conv', ...
                           'filters', 0.01/scal * randn(5, 5, 64, 128, 'single'), ...
                           'biases', bias*ones(1, 128, 'single'), ...
                           'stride', 1, ...
                           'pad', 0, ...
                           'filtersLearningRate', 1, ...
                           'biasesLearningRate', 2, ...
                           'filtersWeightDecay', 1, ...
                           'biasesWeightDecay', 0) ;
net.layers{end+1} = struct('type', 'relu') ;
net.layers{end+1} = struct('type', 'pool', ...
                           'method', 'max', ...
                           'pool', [3 3], ...
                           'stride', 2, ...
                           'pad', 0) ;
                       

net.layers{end+1} = struct('type', 'conv', ...
                           'filters', 0.01/scal * randn(3,3,128,256,'single'), ...
                           'biases', bias*ones(1,256,'single'), ...
                           'stride', 1, ...
                           'pad', 1, ...
                           'filtersLearningRate', 1, ...
                           'biasesLearningRate', 2, ...
                           'filtersWeightDecay', 1, ...
                           'biasesWeightDecay', 0) ;
net.layers{end+1} = struct('type', 'relu') ;

net.layers{end+1} = struct('type', 'conv', ...
                           'filters', 0.01/scal * randn(3,3,256,256,'single'), ...
                           'biases', bias*ones(1,256,'single'), ...
                           'stride', 1, ...
                           'pad', 1, ...
                           'filtersLearningRate', 1, ...
                           'biasesLearningRate', 2, ...
                           'filtersWeightDecay', 1, ...
                           'biasesWeightDecay', 0) ;
net.layers{end+1} = struct('type', 'relu') ;

net.layers{end+1} = struct('type', 'conv', ...
                           'filters', 0.01/scal * randn(3,3,256,256,'single'), ...
                           'biases', bias*ones(1,256,'single'), ...
                           'stride', 1, ...
                           'pad', 1, ...
                           'filtersLearningRate', 1, ...
                           'biasesLearningRate', 2, ...
                           'filtersWeightDecay', 1, ...
                           'biasesWeightDecay', 0) ;
net.layers{end+1} = struct('type', 'relu') ;
net.layers{end+1} = struct('type', 'pool', ...
                           'method', 'max', ...
                           'pool', [3 3], ...
                           'stride', 2, ...
                           'pad', 0) ;

net.layers{end+1} = struct('type', 'conv', ...
                           'filters', 0.01/scal * randn(7,7,256,512,'single'),...
                           'biases', bias*ones(1,512,'single'), ...
                           'stride', 1, ...
                           'pad', 0, ...
                           'filtersLearningRate', 1, ...
                           'biasesLearningRate', 2, ...
                           'filtersWeightDecay', 1, ...
                           'biasesWeightDecay', 0) ;
net.layers{end+1} = struct('type', 'relu') ;
net.layers{end+1} = struct('type', 'dropout', ...
                           'rate', 0.5) ;

net.layers{end+1} = struct('type', 'conv', ...
                           'filters', 0.01/scal * randn(1,1,512,512,'single'),...
                           'biases', bias*ones(1,512,'single'), ...
                           'stride', 1, ...
                           'pad', 0, ...
                           'filtersLearningRate', 1, ...
                           'biasesLearningRate', 2, ...
                           'filtersWeightDecay', 1, ...
                           'biasesWeightDecay', 0) ;
net.layers{end+1} = struct('type', 'relu') ;
net.layers{end+1} = struct('type', 'dropout', ...
                           'rate', 0.5) ;

net.layers{end+1} = struct('type', 'conv', ...
                           'filters', 0.01/scal * randn(1,1,512,250,'single'), ...
                           'biases', bias*ones(1, 250, 'single'), ...
                           'stride', 1, ...
                           'pad', 0, ...
                           'filtersLearningRate', 1, ...
                           'biasesLearningRate', 2, ...
                           'filtersWeightDecay', 1, ...
                           'biasesWeightDecay', 0) ;

net.layers{end+1} = struct('type', 'softmaxloss') ;


imdb.images.data = 255 - imdb.images.data;

if opts.train.useGpu
  imdb.images.data = gpuArray(imdb.images.data) ;
end

[net, info] = cnn_train(net, imdb, @getBatch, ...
    opts.train, ...
    'val', find(imdb.images.set == 3)) ;



function [im, labels] = getBatch(imdb, batch)

N = length(batch);
im = imdb.images.data(:,:,:,batch) ;
labels = imdb.images.labels(1,batch) ;
WH = 225;
RS = 256-WH+1;
im_new = zeros(WH,WH,size(im,3),N,'single'); 
for i = 1:N
    x = randperm(RS,1);
    y = randperm(RS,1);
    roll = rand();
    if roll>0.45
        tmpImg = imrotate(im(:,:,:,i),randi([-5 5],1,1),'bilinear','crop');
    else
        tmpImg = im(:,:,:,i);
    end
    im_new(:,:,:,i) = tmpImg(x:(x+WH-1),y:(y+WH-1),:);
    roll = rand();
    if roll>0.5
        im_new(:,:,:,i) = fliplr(im_new(:,:,:,i));
    end
end
im = im_new;

